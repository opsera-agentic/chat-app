# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  CI BUILD & PUSH - Build Docker images and push to ECR for sperigpt-01       â•‘
# â•‘  Code-to-Cloud v0.6 - Powered by Opsera                                       â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "ðŸ”¨ sperigpt-01: 20 CI Build & Push"

on:
  push:
    branches: [main]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - '.opsera-sperigpt-01/Dockerfile.*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - qa
          - staging
        default: 'qa'

env:
  AWS_REGION: us-west-2
  APP_NAME: sperigpt-01

permissions:
  contents: write
  id-token: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # VERIFY BOOTSTRAP
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  verify-bootstrap:
    name: "ðŸ” Verify Bootstrap"
    runs-on: ubuntu-latest
    outputs:
      ecr_uri: ${{ steps.ecr.outputs.ecr_uri }}
      image_tag: ${{ steps.tag.outputs.image_tag }}

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify ECR Repositories Exist
        id: ecr
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          echo "ecr_uri=${ECR_URI}" >> $GITHUB_OUTPUT

          for REPO in ${{ env.APP_NAME }}-frontend ${{ env.APP_NAME }}-backend; do
            if ! aws ecr describe-repositories --repository-names $REPO 2>/dev/null; then
              echo "âŒ ECR repository $REPO not found. Run Bootstrap first!"
              exit 1
            fi
          done
          echo "âœ… All ECR repositories exist"

      - name: Generate Image Tag
        id: tag
        run: |
          IMAGE_TAG="${GITHUB_SHA:0:7}-$(date +%Y%m%d%H%M%S)"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "### ðŸ·ï¸ Image Tag: \`${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BUILD FRONTEND
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-frontend:
    name: "ðŸ”¨ Build Frontend"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap]

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${{ needs.verify-bootstrap.outputs.ecr_uri }}

      - name: Build and Push Frontend Image
        run: |
          FULL_IMAGE="${{ needs.verify-bootstrap.outputs.ecr_uri }}/${{ env.APP_NAME }}-frontend:${{ needs.verify-bootstrap.outputs.image_tag }}"

          docker build \
            --no-cache \
            --pull \
            -t "$FULL_IMAGE" \
            -f .opsera-${{ env.APP_NAME }}/Dockerfile.frontend \
            ./frontend

          docker push "$FULL_IMAGE"

          echo "### âœ… Frontend Image Built" >> $GITHUB_STEP_SUMMARY
          echo "\`${FULL_IMAGE}\`" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BUILD BACKEND
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-backend:
    name: "ðŸ”¨ Build Backend"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap]

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${{ needs.verify-bootstrap.outputs.ecr_uri }}

      - name: Build and Push Backend Image
        run: |
          FULL_IMAGE="${{ needs.verify-bootstrap.outputs.ecr_uri }}/${{ env.APP_NAME }}-backend:${{ needs.verify-bootstrap.outputs.image_tag }}"

          docker build \
            --no-cache \
            --pull \
            -t "$FULL_IMAGE" \
            -f .opsera-${{ env.APP_NAME }}/Dockerfile.backend \
            ./backend

          docker push "$FULL_IMAGE"

          echo "### âœ… Backend Image Built" >> $GITHUB_STEP_SUMMARY
          echo "\`${FULL_IMAGE}\`" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # UPDATE MANIFESTS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-manifests:
    name: "ðŸ“ Update Manifests (${{ inputs.environment || 'qa' }})"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, build-frontend, build-backend]

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Update Kustomization with New Image Tag
        env:
          IMAGE_TAG: ${{ needs.verify-bootstrap.outputs.image_tag }}
          ENVIRONMENT: ${{ inputs.environment || 'qa' }}
        run: |
          KUSTOMIZE_FILE=".opsera-${{ env.APP_NAME }}/k8s/overlays/${ENVIRONMENT}/kustomization.yaml"

          # RULE 8: Pull before modify
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull --rebase origin main || true

          # Update all image tags
          sed -i "s|newTag:.*|newTag: ${IMAGE_TAG}|g" "$KUSTOMIZE_FILE"

          echo "âœ… Updated kustomization.yaml with tag: ${IMAGE_TAG}"

      - name: Commit and Push Changes
        env:
          ENVIRONMENT: ${{ inputs.environment || 'qa' }}
        run: |
          git add .
          git diff --staged --quiet || git commit -m "chore(${ENVIRONMENT}): update images to ${{ needs.verify-bootstrap.outputs.image_tag }} [skip ci]"
          git push origin main || echo "No changes to push"

      - name: Summary
        run: |
          echo "### ðŸ“ Manifests Updated" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Image Tag |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-----------|" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | \`${{ needs.verify-bootstrap.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend | \`${{ needs.verify-bootstrap.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ArgoCD will automatically sync the new images." >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # TRIGGER ARGOCD SYNC
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  sync-argocd:
    name: "ðŸ”„ Sync ArgoCD"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, update-manifests]

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Sync ArgoCD Application
        env:
          ENVIRONMENT: ${{ inputs.environment || 'qa' }}
        run: |
          HUB_CLUSTER="argocd-usw2"
          aws eks update-kubeconfig --name $HUB_CLUSTER --region ${{ env.AWS_REGION }}

          APP_NAME="${{ env.APP_NAME }}-${ENVIRONMENT}"

          # Hard refresh and sync
          kubectl patch application "$APP_NAME" -n argocd \
            --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'

          sleep 5

          kubectl patch application "$APP_NAME" -n argocd \
            --type merge -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"prune":true}}}'

          echo "### ðŸ”„ ArgoCD Sync Triggered" >> $GITHUB_STEP_SUMMARY
          echo "- Application: \`$APP_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "- Environment: \`${ENVIRONMENT}\`" >> $GITHUB_STEP_SUMMARY
