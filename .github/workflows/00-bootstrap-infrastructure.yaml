# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  BOOTSTRAP INFRASTRUCTURE - One-time setup for chat-app                       â•‘
# â•‘  Generated by Code-to-Cloud v0.6 - Powered by Opsera                          â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "ðŸš€ 00: Bootstrap Infrastructure"

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: string
        default: 'qa'

env:
  AWS_REGION: us-west-2
  TENANT: opsera
  APP_NAME: chat-app

permissions:
  contents: write
  id-token: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DISCOVER INFRASTRUCTURE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  discover:
    name: "ðŸ” Discover Infrastructure"
    runs-on: ubuntu-latest
    outputs:
      hub_cluster: ${{ steps.discover.outputs.hub_cluster }}
      spoke_cluster: ${{ steps.discover.outputs.spoke_cluster }}
      region_short: ${{ steps.discover.outputs.region_short }}
      subdomain: ${{ steps.discover.outputs.subdomain }}
      
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Discover Clusters and Generate Names
        id: discover
        run: |
          # Generate region short code
          case "${{ env.AWS_REGION }}" in
            us-west-2) REGION_SHORT="usw2" ;;
            us-east-1) REGION_SHORT="use1" ;;
            us-west-1) REGION_SHORT="usw1" ;;
            eu-west-1) REGION_SHORT="euw1" ;;
            *) REGION_SHORT=$(echo "${{ env.AWS_REGION }}" | sed 's/-//g' | cut -c1-4) ;;
          esac
          
          # Determine environment suffix (qa = non-prod)
          ENV_SUFFIX="np"
          
          HUB_CLUSTER="argocd-${REGION_SHORT}"
          SPOKE_CLUSTER="${{ env.TENANT }}-${REGION_SHORT}-${ENV_SUFFIX}"
          SUBDOMAIN="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}.agent.opsera.dev"
          
          echo "hub_cluster=${HUB_CLUSTER}" >> $GITHUB_OUTPUT
          echo "spoke_cluster=${SPOKE_CLUSTER}" >> $GITHUB_OUTPUT
          echo "region_short=${REGION_SHORT}" >> $GITHUB_OUTPUT
          echo "subdomain=${SUBDOMAIN}" >> $GITHUB_OUTPUT
          
          echo "### ðŸ” Infrastructure Discovery" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Hub Cluster | \`${HUB_CLUSTER}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Spoke Cluster | \`${SPOKE_CLUSTER}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Subdomain | \`${SUBDOMAIN}\` |" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PRE-FLIGHT CHECKS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  preflight:
    name: "âœ… Pre-flight Checks"
    runs-on: ubuntu-latest
    needs: [discover]
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: CHECK 1 - Verify Clusters Exist
        run: |
          echo "Checking Hub cluster: ${{ needs.discover.outputs.hub_cluster }}"
          aws eks describe-cluster --name ${{ needs.discover.outputs.hub_cluster }} --region ${{ env.AWS_REGION }}
          
          echo "Checking Spoke cluster: ${{ needs.discover.outputs.spoke_cluster }}"
          aws eks describe-cluster --name ${{ needs.discover.outputs.spoke_cluster }} --region ${{ env.AWS_REGION }}

      - name: CHECK 2 - Verify Subdomain Available
        run: |
          SUBDOMAIN="${{ needs.discover.outputs.subdomain }}"
          HOSTED_ZONE_ID=$(aws route53 list-hosted-zones-by-name \
            --dns-name "agent.opsera.dev" \
            --query "HostedZones[?Name=='agent.opsera.dev.'].Id" \
            --output text | sed 's|/hostedzone/||')
          
          if [ -z "$HOSTED_ZONE_ID" ]; then
            echo "âš ï¸ Hosted zone not found - will be created during HTTPS setup"
          else
            EXISTING=$(aws route53 list-resource-record-sets \
              --hosted-zone-id "$HOSTED_ZONE_ID" \
              --query "ResourceRecordSets[?Name=='${SUBDOMAIN}.']" \
              --output json)
            
            COUNT=$(echo "$EXISTING" | jq 'length')
            if [ "$COUNT" -gt 0 ]; then
              echo "âš ï¸ Subdomain ${SUBDOMAIN} already has records"
              echo "$EXISTING" | jq -r '.[] | "\(.Type): \(.Name)"'
            else
              echo "âœ… Subdomain ${SUBDOMAIN} is available"
            fi
          fi

      - name: CHECK 3 - Verify Argo Rollouts Installed
        run: |
          aws eks update-kubeconfig --name ${{ needs.discover.outputs.spoke_cluster }} --region ${{ env.AWS_REGION }}
          
          if kubectl get crd rollouts.argoproj.io &>/dev/null; then
            echo "âœ… Argo Rollouts is installed"
          else
            echo "âš ï¸ Argo Rollouts not found - installing..."
            kubectl create namespace argo-rollouts || true
            kubectl apply -n argo-rollouts -f https://github.com/argoproj/argo-rollouts/releases/latest/download/install.yaml
            echo "âœ… Argo Rollouts installed"
          fi

      - name: CHECK 4 - Verify Dockerfiles Exist
        run: |
          if [ -f ".opsera-${{ env.APP_NAME }}/Dockerfile.frontend" ] && [ -f ".opsera-${{ env.APP_NAME }}/Dockerfile.backend" ]; then
            echo "âœ… Dockerfiles exist"
          else
            echo "âŒ Dockerfiles not found"
            ls -la .opsera-${{ env.APP_NAME }}/ || echo "Directory not found"
            exit 1
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SETUP ARGOCD
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  setup-argocd:
    name: "ðŸ”§ Setup ArgoCD Application"
    runs-on: ubuntu-latest
    needs: [discover, preflight]
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Update ArgoCD Application Manifest
        run: |
          APP_MANIFEST=".opsera-${{ env.APP_NAME }}/argocd/application-${{ inputs.environment }}.yaml"
          
          # Update repository URL from git remote
          REPO_URL=$(git remote get-url origin)
          sed -i "s|repoURL:.*|repoURL: ${REPO_URL}|" "$APP_MANIFEST"
          
          echo "âœ… Updated ArgoCD manifest with repo: ${REPO_URL}"

      - name: Update Ingress Subdomain
        run: |
          PATCH_FILE=".opsera-${{ env.APP_NAME }}/k8s/overlays/${{ inputs.environment }}/patch-ingress.yaml"
          SUBDOMAIN="${{ needs.discover.outputs.subdomain }}"
          
          if [ -f "$PATCH_FILE" ]; then
            sed -i "s/PLACEHOLDER_SUBDOMAIN/${SUBDOMAIN}/g" "$PATCH_FILE"
            echo "âœ… Updated ingress subdomain to: ${SUBDOMAIN}"
          fi

      - name: Commit Changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull --rebase origin main || true
          git add .
          git diff --staged --quiet || git commit -m "chore: configure ${{ env.APP_NAME }} for ${{ inputs.environment }} [skip ci]"
          git push origin main || echo "No changes to push"

      - name: Connect to Hub and Apply ArgoCD Application
        run: |
          aws eks update-kubeconfig --name ${{ needs.discover.outputs.hub_cluster }} --region ${{ env.AWS_REGION }}
          
          # Create ArgoCD repo secret if not exists
          kubectl get secret repo-${{ github.repository_owner }}-${{ env.APP_NAME }} -n argocd 2>/dev/null || \
          kubectl create secret generic repo-${{ github.repository_owner }}-${{ env.APP_NAME }} \
            -n argocd \
            --from-literal=url=$(git remote get-url origin) \
            --from-literal=password=${{ secrets.GH_PAT }} \
            --from-literal=username=git \
            --from-literal=type=git
          
          kubectl label secret repo-${{ github.repository_owner }}-${{ env.APP_NAME }} \
            -n argocd argocd.argoproj.io/secret-type=repository --overwrite
          
          # Apply ArgoCD Application
          kubectl apply -f .opsera-${{ env.APP_NAME }}/argocd/application-${{ inputs.environment }}.yaml
          
          echo "âœ… ArgoCD Application applied"

      - name: Verify ArgoCD Application Created
        run: |
          sleep 10
          kubectl get application ${{ env.APP_NAME }}-${{ inputs.environment }} -n argocd
          
          SYNC_STATUS=$(kubectl get application ${{ env.APP_NAME }}-${{ inputs.environment }} -n argocd \
            -o jsonpath='{.status.sync.status}')
          
          echo "### ðŸŽ¯ ArgoCD Application Status" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Application | \`${{ env.APP_NAME }}-${{ inputs.environment }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Sync Status | \`${SYNC_STATUS}\` |" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SETUP CANARY ANALYSIS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  setup-canary-analysis:
    name: "ðŸ“ˆ Setup Canary Analysis Templates"
    runs-on: ubuntu-latest
    needs: [discover, setup-argocd]
    if: inputs.environment == 'qa'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Connect to Spoke Cluster
        run: |
          aws eks update-kubeconfig --name ${{ needs.discover.outputs.spoke_cluster }} --region ${{ env.AWS_REGION }}

      - name: Create Namespace and Apply Analysis Templates
        run: |
          NAMESPACE="${{ env.APP_NAME }}-${{ inputs.environment }}"
          kubectl create namespace $NAMESPACE || true
          
          # Apply analysis templates
          kubectl apply -f .opsera-${{ env.APP_NAME }}/k8s/base/rollouts/analysis-template-http.yaml -n $NAMESPACE || true
          
          echo "### ðŸ“Š QA Canary Setup" >> $GITHUB_STEP_SUMMARY
          echo "- Analysis templates applied" >> $GITHUB_STEP_SUMMARY
          echo "- Strategy: Canary (10% â†’ 30% â†’ 60% â†’ 100%)" >> $GITHUB_STEP_SUMMARY
          echo "- Namespace: \`$NAMESPACE\`" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SUMMARY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  summary:
    name: "ðŸ“‹ Bootstrap Summary"
    runs-on: ubuntu-latest
    needs: [discover, preflight, setup-argocd]
    if: always()
    
    steps:
      - name: Generate Summary
        run: |
          echo "## ðŸš€ Bootstrap Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Application | \`${{ env.APP_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${{ inputs.environment }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Hub Cluster | \`${{ needs.discover.outputs.hub_cluster }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Spoke Cluster | \`${{ needs.discover.outputs.spoke_cluster }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | \`https://${{ needs.discover.outputs.subdomain }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Run **CI: Build & Push** workflow to build Docker images" >> $GITHUB_STEP_SUMMARY
          echo "2. Run **HTTPS Setup** workflow for SSL certificate" >> $GITHUB_STEP_SUMMARY
          echo "3. Monitor canary deployment with **Canary Watch Dashboard**" >> $GITHUB_STEP_SUMMARY
