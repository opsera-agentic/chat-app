# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CI/CD Pipeline - chatgptsperi6
# Generated by Opsera Code-to-Cloud Enterprise v1.7.3
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "chatgptsperi6: CI Build & Push"

on:
  push:
    branches: [main]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - '.opsera-chatgptsperi6/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        type: choice
        options: [dev]
        default: 'dev'
      skip_build:
        description: 'Skip build (use existing image)'
        type: boolean
        default: false
      image_tag:
        description: 'Existing image tag (if skip_build=true)'
        type: string

env:
  APP_NAME: chatgptsperi6
  AWS_REGION: us-west-2
  EKS_CLUSTER: opsera-usw2-np
  HUB_CLUSTER: argocd-usw2
  TENANT: opsera

permissions:
  contents: write
  id-token: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # VERIFY PREREQUISITES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  verify-prerequisites:
    name: "ğŸ” Verify Prerequisites"
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      image_tag: ${{ steps.tag.outputs.image_tag }}
      ecr_frontend: ${{ steps.ecr.outputs.frontend }}
      ecr_backend: ${{ steps.ecr.outputs.backend }}
      aws_account_id: ${{ steps.account.outputs.account_id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID
        id: account
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${ACCOUNT_ID}" >> $GITHUB_OUTPUT
          echo "AWS Account: ${ACCOUNT_ID}"

      - name: Determine Environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
          else
            echo "environment=${{ inputs.environment || 'dev' }}" >> $GITHUB_OUTPUT
          fi

      - name: Generate Image Tag
        id: tag
        run: |
          if [ "${{ inputs.skip_build }}" = "true" ] && [ -n "${{ inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ inputs.image_tag }}"
          else
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
          fi
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Image tag: ${IMAGE_TAG}"

      - name: Set ECR Repository URLs
        id: ecr
        run: |
          ACCOUNT_ID="${{ steps.account.outputs.account_id }}"
          ECR_BASE="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          echo "frontend=${ECR_BASE}/${{ env.TENANT }}/${{ env.APP_NAME }}-frontend" >> $GITHUB_OUTPUT
          echo "backend=${ECR_BASE}/${{ env.TENANT }}/${{ env.APP_NAME }}-backend" >> $GITHUB_OUTPUT

      - name: Verify/Create ECR Repositories
        run: |
          for REPO in "${{ env.TENANT }}/${{ env.APP_NAME }}-frontend" "${{ env.TENANT }}/${{ env.APP_NAME }}-backend"; do
            if aws ecr describe-repositories --repository-names "$REPO" 2>/dev/null; then
              echo "âœ… ECR repository exists: $REPO"
            else
              echo "ğŸ“¦ Creating ECR repository: $REPO"
              aws ecr create-repository --repository-name "$REPO" --image-scanning-configuration scanOnPush=true
            fi
          done

      - name: Verify EKS Cluster
        run: |
          if aws eks describe-cluster --name ${{ env.EKS_CLUSTER }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "âœ… EKS cluster exists: ${{ env.EKS_CLUSTER }}"
          else
            echo "âŒ EKS cluster not found: ${{ env.EKS_CLUSTER }}"
            exit 1
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BUILD & PUSH FRONTEND
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-frontend:
    name: "ğŸ”¨ Build Frontend"
    needs: [verify-prerequisites]
    if: inputs.skip_build != true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ needs.verify-prerequisites.outputs.ecr_frontend }}

      - name: Build and Push Frontend
        run: |
          ECR_URI="${{ needs.verify-prerequisites.outputs.ecr_frontend }}"
          IMAGE_TAG="${{ needs.verify-prerequisites.outputs.image_tag }}"

          docker build -t ${ECR_URI}:${IMAGE_TAG} -f frontend/Dockerfile ./frontend
          docker tag ${ECR_URI}:${IMAGE_TAG} ${ECR_URI}:latest

          docker push ${ECR_URI}:${IMAGE_TAG}
          docker push ${ECR_URI}:latest

          echo "âœ… Frontend pushed: ${ECR_URI}:${IMAGE_TAG}"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BUILD & PUSH BACKEND
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-backend:
    name: "ğŸ”¨ Build Backend"
    needs: [verify-prerequisites]
    if: inputs.skip_build != true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ needs.verify-prerequisites.outputs.ecr_backend }}

      - name: Build and Push Backend
        run: |
          ECR_URI="${{ needs.verify-prerequisites.outputs.ecr_backend }}"
          IMAGE_TAG="${{ needs.verify-prerequisites.outputs.image_tag }}"

          docker build -t ${ECR_URI}:${IMAGE_TAG} -f backend/Dockerfile ./backend
          docker tag ${ECR_URI}:${IMAGE_TAG} ${ECR_URI}:latest

          docker push ${ECR_URI}:${IMAGE_TAG}
          docker push ${ECR_URI}:latest

          echo "âœ… Backend pushed: ${ECR_URI}:${IMAGE_TAG}"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # UPDATE MANIFESTS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-manifests:
    name: "ğŸ“ Update Manifests"
    needs: [verify-prerequisites, build-frontend, build-backend]
    if: always() && needs.verify-prerequisites.result == 'success' && (needs.build-frontend.result == 'success' || needs.build-frontend.result == 'skipped') && (needs.build-backend.result == 'success' || needs.build-backend.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update Kustomization with new image tags
        run: |
          ENVIRONMENT="${{ needs.verify-prerequisites.outputs.environment }}"
          IMAGE_TAG="${{ needs.verify-prerequisites.outputs.image_tag }}"
          ECR_FRONTEND="${{ needs.verify-prerequisites.outputs.ecr_frontend }}"
          ECR_BACKEND="${{ needs.verify-prerequisites.outputs.ecr_backend }}"

          OVERLAY_PATH=".opsera-${{ env.APP_NAME }}/k8s/overlays/${ENVIRONMENT}/kustomization.yaml"

          # Update frontend image
          sed -i "s|newName: .*chatgptsperi6-frontend.*|newName: ${ECR_FRONTEND}|g" "$OVERLAY_PATH"
          sed -i "s|newName: PLACEHOLDER_ECR_FRONTEND|newName: ${ECR_FRONTEND}|g" "$OVERLAY_PATH"

          # Update backend image
          sed -i "s|newName: .*chatgptsperi6-backend.*|newName: ${ECR_BACKEND}|g" "$OVERLAY_PATH"
          sed -i "s|newName: PLACEHOLDER_ECR_BACKEND|newName: ${ECR_BACKEND}|g" "$OVERLAY_PATH"

          # Update tag for both
          sed -i "s|newTag: .*|newTag: ${IMAGE_TAG}|g" "$OVERLAY_PATH"

          # Also update base kustomization
          BASE_PATH=".opsera-${{ env.APP_NAME }}/k8s/base/kustomization.yaml"
          sed -i "s|newName: PLACEHOLDER_ECR_FRONTEND|newName: ${ECR_FRONTEND}|g" "$BASE_PATH"
          sed -i "s|newName: PLACEHOLDER_ECR_BACKEND|newName: ${ECR_BACKEND}|g" "$BASE_PATH"

          echo "Updated manifests with image tag: ${IMAGE_TAG}"
          cat "$OVERLAY_PATH"

      - name: Commit and Push
        run: |
          git add .opsera-${{ env.APP_NAME }}/

          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            git commit -m "$(cat <<'EOF'
          chore(${{ env.APP_NAME }}): update images to ${{ needs.verify-prerequisites.outputs.image_tag }} [skip ci]

          Environment: ${{ needs.verify-prerequisites.outputs.environment }}
          Image: ${{ needs.verify-prerequisites.outputs.image_tag }}

          Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
          EOF
          )"

            git pull --rebase origin main
            git push origin main
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SYNC ARGOCD & WAIT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  sync-and-wait:
    name: "ğŸ”„ Sync & Deploy"
    needs: [verify-prerequisites, update-manifests]
    if: always() && needs.update-manifests.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      deploy_success: ${{ steps.wait.outputs.success }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl for Hub Cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Force ArgoCD Sync
        run: |
          APP_NAME="${{ env.APP_NAME }}-${{ needs.verify-prerequisites.outputs.environment }}"

          # Check if application exists
          if kubectl get application $APP_NAME -n argocd >/dev/null 2>&1; then
            echo "Triggering ArgoCD sync for $APP_NAME..."
            kubectl annotate application $APP_NAME -n argocd \
              argocd.argoproj.io/refresh=hard --overwrite
            echo "âœ… ArgoCD sync triggered"
          else
            echo "âš ï¸ ArgoCD application not found: $APP_NAME"
            echo "Run the bootstrap workflow first to create the ArgoCD application"
            exit 1
          fi

      - name: Configure kubectl for Spoke Cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Wait for Deployment
        id: wait
        run: |
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ needs.verify-prerequisites.outputs.environment }}"
          TIMEOUT=300  # 5 minutes for DEV
          ELAPSED=0

          echo "Waiting for pods in namespace: $NAMESPACE"

          while [ $ELAPSED -lt $TIMEOUT ]; do
            # Check if namespace exists
            if ! kubectl get namespace $NAMESPACE >/dev/null 2>&1; then
              echo "Namespace $NAMESPACE not found yet, waiting..."
              sleep 15
              ELAPSED=$((ELAPSED + 15))
              continue
            fi

            # Get pod status
            READY=$(kubectl get pods -n $NAMESPACE -o jsonpath='{.items[*].status.phase}' 2>/dev/null | tr ' ' '\n' | grep -c Running || echo 0)
            TOTAL=$(kubectl get pods -n $NAMESPACE --no-headers 2>/dev/null | wc -l | tr -d ' ')

            echo "Pods: $READY/$TOTAL running (elapsed: ${ELAPSED}s)"

            if [ "$TOTAL" -gt 0 ] && [ "$READY" -eq "$TOTAL" ]; then
              echo "âœ… All pods running!"
              echo "success=true" >> $GITHUB_OUTPUT
              exit 0
            fi

            sleep 15
            ELAPSED=$((ELAPSED + 15))
          done

          echo "âš ï¸ Deployment timeout - check pod status"
          kubectl get pods -n $NAMESPACE -o wide || true
          echo "success=false" >> $GITHUB_OUTPUT

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SUMMARY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  summary:
    name: "ğŸ“‹ Summary"
    needs: [verify-prerequisites, build-frontend, build-backend, update-manifests, sync-and-wait]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate Summary
        run: |
          cat << EOF >> $GITHUB_STEP_SUMMARY
          # ğŸš€ Deployment Summary - ${{ env.APP_NAME }}

          ## Pipeline Status
          | Stage | Status |
          |-------|--------|
          | Prerequisites | ${{ needs.verify-prerequisites.result }} |
          | Build Frontend | ${{ needs.build-frontend.result }} |
          | Build Backend | ${{ needs.build-backend.result }} |
          | Update Manifests | ${{ needs.update-manifests.result }} |
          | Deploy | ${{ needs.sync-and-wait.result }} |

          ## Deployment Details
          | Field | Value |
          |-------|-------|
          | **Environment** | ${{ needs.verify-prerequisites.outputs.environment }} |
          | **Image Tag** | \`${{ needs.verify-prerequisites.outputs.image_tag }}\` |
          | **Cluster** | ${{ env.EKS_CLUSTER }} |
          | **Namespace** | ${{ env.TENANT }}-${{ env.APP_NAME }}-${{ needs.verify-prerequisites.outputs.environment }} |

          ## Images
          - Frontend: \`${{ needs.verify-prerequisites.outputs.ecr_frontend }}:${{ needs.verify-prerequisites.outputs.image_tag }}\`
          - Backend: \`${{ needs.verify-prerequisites.outputs.ecr_backend }}:${{ needs.verify-prerequisites.outputs.image_tag }}\`

          ## URLs
          - ğŸŒ **Application**: https://opsera-${{ env.APP_NAME }}-${{ needs.verify-prerequisites.outputs.environment }}.agent.opsera.dev

          ---
          *Powered by Opsera Code-to-Cloud Enterprise v1.7.3*
          EOF
